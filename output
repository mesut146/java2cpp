#pragma once

#include "com::android::dex::Code::CatchHandler.h"
#include "com::android::dex::Code::Try.h"
#include "com::android::dex::MethodHandle::MethodHandleType.h"
#include "com::android::dex::util::ByteInput.h"
#include "com::android::dex::util::ByteOutput.h"
#include "com::android::dex::util::FileUtils.h"
#include "java::io::ByteArrayOutputStream.h"
#include "java::io::File.h"
#include "java::io::FileInputStream.h"
#include "java::io::FileOutputStream.h"
#include "java::io::IOException.h"
#include "java::io::InputStream.h"
#include "java::io::OutputStream.h"
#include "java::io::UTFDataFormatException.h"
#include "java::nio::ByteBuffer.h"
#include "java::nio::ByteOrder.h"
#include "java::security::MessageDigest.h"
#include "java::security::NoSuchAlgorithmException.h"
#include "java::util::AbstractList.h"
#include "java::util::Collections.h"
#include "java::util::Iterator.h"
#include "java::util::List.h"
#include "java::util::NoSuchElementException.h"
#include "java::util::RandomAccess.h"
#include "java::util::zip::Adler32.h"
#include "java::util::zip::ZipEntry.h"
#include "java::util::zip::ZipFile.h"

namespace com::android::dex{
    class Dex{

        static int CHECKSUM_OFFSET=8;
        static int CHECKSUM_SIZE=4;
        static int SIGNATURE_OFFSET=CHECKSUM_OFFSET+CHECKSUM_SIZE;
        static int SIGNATURE_SIZE=20;
        static short[] EMPTY_SHORT_ARRAY=new short[0];
        ByteBuffer* data;
        TableOfContents* tableOfContents=new TableOfContents();
        int nextSectionStart=0;
        StringTable* strings=new StringTable();
        TypeIndexToDescriptorIndexTable* typeIds=new TypeIndexToDescriptorIndexTable();
        TypeIndexToDescriptorTable* typeNames=new TypeIndexToDescriptorTable();
        ProtoIdTable* protoIds=new ProtoIdTable();
        FieldIdTable* fieldIds=new FieldIdTable();
        MethodIdTable* methodIds=new MethodIdTable();

        Dex(byte[] data);
        Dex(ByteBuffer* data);
        Dex(int byteCount);
        Dex(InputStream* in);
        Dex(File* file);
        void loadFrom(InputStream* in);
        static void checkBounds(int index,int length);
        void writeTo(OutputStream* out);
        void writeTo(File* dexOut);
        TableOfContents* getTableOfContents();
        Section* open(int position);
        Section* appendSection(int maxByteCount,String* name);
        int getLength();
        int getNextSectionStart();
        byte[] getBytes();
        List<String>* strings();
        List<Integer>* typeIds();
        List<String>* typeNames();
        List<ProtoId>* protoIds();
        List<FieldId>* fieldIds();
        List<MethodId>* methodIds();
        Iterable<ClassDef>* classDefs();
        TypeList* readTypeList(int offset);
        ClassData* readClassData(ClassDef* classDef);
        Code* readCode(ClassData::Method* method);
        byte[] computeSignature();
        int computeChecksum();
        void writeHashes();
        int descriptorIndexFromTypeIndex(int typeIndex);

        class Section:ByteInput,ByteOutput{

            String* name;
            ByteBuffer* data;
            int initialPosition;

            Section(String* name,ByteBuffer* data);
            int getPosition();
            int readInt();
            short readShort();
            int readUnsignedShort();
            byte readByte();
            byte[] readByteArray(int length);
            short[] readShortArray(int length);
            int readUleb128();
            int readUleb128p1();
            int readSleb128();
            void writeUleb128p1(int i);
            TypeList* readTypeList();
            String* readString();
            FieldId* readFieldId();
            MethodId* readMethodId();
            ProtoId* readProtoId();
            CallSiteId* readCallSiteId();
            MethodHandle* readMethodHandle();
            ClassDef* readClassDef();
            Code* readCode();
            CatchHandler[] readCatchHandlers();
            Try[] readTries(int triesSize,CatchHandler[] catchHandlers);
            int findCatchHandlerIndex(CatchHandler[] catchHandlers,int offset);
            CatchHandler* readCatchHandler(int offset);
            ClassData* readClassData();
            ClassData.Field[] readFields(int count);
            ClassData.Method[] readMethods(int count);
            byte[] getBytesFrom(int start);
            Annotation* readAnnotation();
            EncodedValue* readEncodedArray();
            void skip(int count);
            void alignToFourBytes();
            void alignToFourBytesWithZeroFill();
            void assertFourByteAligned();
            void write(byte[] bytes);
            void writeByte(int b);
            void writeShort(short i);
            void writeUnsignedShort(int i);
            void write(short[] shorts);
            void writeInt(int i);
            void writeUleb128(int i);
            void writeSleb128(int i);
            void writeStringData(String* value);
            void writeTypeList(TypeList* typeList);
            int used();

        };//class Section

        class StringTable:AbstractList,RandomAccess{


            String* get(int index);
            int size();

        };//class StringTable

        class TypeIndexToDescriptorIndexTable:AbstractList,RandomAccess{


            Integer get(int index);
            int size();

        };//class TypeIndexToDescriptorIndexTable

        class TypeIndexToDescriptorTable:AbstractList,RandomAccess{


            String* get(int index);
            int size();

        };//class TypeIndexToDescriptorTable

        class ProtoIdTable:AbstractList,RandomAccess{


            ProtoId* get(int index);
            int size();

        };//class ProtoIdTable

        class FieldIdTable:AbstractList,RandomAccess{


            FieldId* get(int index);
            int size();

        };//class FieldIdTable

        class MethodIdTable:AbstractList,RandomAccess{


            MethodId* get(int index);
            int size();

        };//class MethodIdTable

        class ClassDefIterator:Iterator{

            Section* in=open(tableOfContents->classDefs->off);
            int count=0;

            boolean hasNext();
            ClassDef* next();
            void remove();

        };//class ClassDefIterator

        class ClassDefIterable:Iterable{


            Iterator<ClassDef>* iterator();

        };//class ClassDefIterable

    };//class Dex
}//ns

---------------
#include "test.h"


::Dex(byte[] data){
    ByteBuffer->wrap(data)
}

::Dex(ByteBuffer* data){
    this->data=data;
    this->data->order(ByteOrder->LITTLE_ENDIAN);
    this->tableOfContents->readFrom(this);
}

::Dex(int byteCount){
    this->data=ByteBuffer->wrap(new byte[byteCount]);
    this->data->order(ByteOrder->LITTLE_ENDIAN);
}

::Dex(InputStream* in){
    try{
        loadFrom(in);
    }{
        in->close();
    }
}

::Dex(File* file){
    if(FileUtils->hasArchiveSuffix(file->getName())){
        ZipFile* zipFile=new ZipFile(file);
        ZipEntry* entry=zipFile->getEntry(DexFormat->DEX_IN_JAR_NAME);
        if(entry!=nullptr){
            try(InputStream* inputStream=zipFile->getInputStream(entry)){
                loadFrom(inputStream);
            }
            zipFile->close();
        }else{
            throw new DexException(new String("Expected ")+DexFormat->DEX_IN_JAR_NAME+new String(" in ")+file)
        }
    }else if(file->getName()->endsWith(new String(".dex"))){
        try(InputStream* inputStream=new FileInputStream(file)){
            loadFrom(inputStream);
        }
    }else{
        throw new DexException(new String("unknown output extension: ")+file)
    }
}

void ::loadFrom(InputStream* in){
    ByteArrayOutputStream* bytesOut=new ByteArrayOutputStream();
    byte[] buffer=new byte[8192];
    int count;
    while(count=in->read(buffer)!=1){
        bytesOut->write(buffer,0,count);
    }
    this->data=ByteBuffer->wrap(bytesOut->toByteArray());
    this->data->order(ByteOrder->LITTLE_ENDIAN);
    this->tableOfContents->readFrom(this);
}

static void ::checkBounds(int index,int length){
    if(index<0||index>=length){
        throw new IndexOutOfBoundsException(new String("index:")+index+new String(", length=")+length)
    }
}

void ::writeTo(OutputStream* out){
    byte[] buffer=new byte[8192];
    ByteBuffer* data=this->data->duplicate();
    data->clear();
    while(data->hasRemaining()){
        int count=Math->min(buffer->length,data->remaining());
        data->get(buffer,0,count);
        out->write(buffer,0,count);
    }
}

void ::writeTo(File* dexOut){
    try(OutputStream* out=new FileOutputStream(dexOut)){
        writeTo(out);
    }
}

TableOfContents* ::getTableOfContents(){
    return tableOfContents;
}

Section* ::open(int position){
    if(position<0||position>=data->capacity()){
        throw new IllegalArgumentException(new String("position=")+position+new String(" length=")+data->capacity())
    }
    ByteBuffer* sectionData=data->duplicate();
    sectionData->order(ByteOrder->LITTLE_ENDIAN);
    sectionData->position(position);
    sectionData->limit(data->capacity());
    return new Section(new String("section"),sectionData);
}

Section* ::appendSection(int maxByteCount,String* name){
    if(maxByteCount&3!=0){
        throw new IllegalStateException(new String("Not four byte aligned!"))
    }
    int limit=nextSectionStart+maxByteCount;
    ByteBuffer* sectionData=data->duplicate();
    sectionData->order(ByteOrder->LITTLE_ENDIAN);
    sectionData->position(nextSectionStart);
    sectionData->limit(limit);
    Section* result=new Section(name,sectionData);
    nextSectionStart=limit;
    return result;
}

int ::getLength(){
    return data->capacity();
}

int ::getNextSectionStart(){
    return nextSectionStart;
}

byte[] ::getBytes(){
    ByteBuffer* data=this->data->duplicate();
    byte[] result=new byte[data->capacity()];
    data->position(0);
    data->get(result);
    return result;
}

List<String>* ::strings(){
    return strings;
}

List<Integer>* ::typeIds(){
    return typeIds;
}

List<String>* ::typeNames(){
    return typeNames;
}

List<ProtoId>* ::protoIds(){
    return protoIds;
}

List<FieldId>* ::fieldIds(){
    return fieldIds;
}

List<MethodId>* ::methodIds(){
    return methodIds;
}

Iterable<ClassDef>* ::classDefs(){
    return new ClassDefIterable();
}

TypeList* ::readTypeList(int offset){
    if(offset==0){
        return TypeList->EMPTY;
    }
    return open(offset)->readTypeList();
}

ClassData* ::readClassData(ClassDef* classDef){
    int offset=classDef->getClassDataOffset();
    if(offset==0){
        throw new IllegalArgumentException(new String("offset == 0"))
    }
    return open(offset)->readClassData();
}

Code* ::readCode(ClassData::Method* method){
    int offset=method->getCodeOffset();
    if(offset==0){
        throw new IllegalArgumentException(new String("offset == 0"))
    }
    return open(offset)->readCode();
}

byte[] ::computeSignature(){
    MessageDigest* digest;
    try{
        digest=MessageDigest->getInstance(new String("SHA-1"));
    }catch(NoSuchAlgorithmException e){
        throw new AssertionError()
    }
    byte[] buffer=new byte[8192];
    ByteBuffer* data=this->data->duplicate();
    data->limit(data->capacity());
    data->position(SIGNATURE_OFFSET+SIGNATURE_SIZE);
    while(data->hasRemaining()){
        int count=Math->min(buffer->length,data->remaining());
        data->get(buffer,0,count);
        digest->update(buffer,0,count);
    }
    return digest->digest();
}

int ::computeChecksum(){
    Adler32* adler32=new Adler32();
    byte[] buffer=new byte[8192];
    ByteBuffer* data=this->data->duplicate();
    data->limit(data->capacity());
    data->position(CHECKSUM_OFFSET+CHECKSUM_SIZE);
    while(data->hasRemaining()){
        int count=Math->min(buffer->length,data->remaining());
        data->get(buffer,0,count);
        adler32->update(buffer,0,count);
    }
    return adler32->getValue();
}

void ::writeHashes(){
    open(SIGNATURE_OFFSET)->write(computeSignature());
    open(CHECKSUM_OFFSET)->writeInt(computeChecksum());
}

int ::descriptorIndexFromTypeIndex(int typeIndex){
    checkBounds(typeIndex,tableOfContents->typeIds->size);
    int position=tableOfContents->typeIds->off+SizeOf->TYPE_ID_ITEM*typeIndex;
    return data->getInt(position);
}

::Section(String* name,ByteBuffer* data){
    this->name=name;
    this->data=data;
    this->initialPosition=data->position();
}

int ::getPosition(){
    return data->position();
}

int ::readInt(){
    return data->getInt();
}

short ::readShort(){
    return data->getShort();
}

int ::readUnsignedShort(){
    return readShort()&0xffff;
}

byte ::readByte(){
    return data->get();
}

byte[] ::readByteArray(int length){
    byte[] result=new byte[length];
    data->get(result);
    return result;
}

short[] ::readShortArray(int length){
    if(length==0){
        return EMPTY_SHORT_ARRAY;
    }
    short[] result=new short[length];
    for(int i=0;i<length;i){
        iresult=readShort();
    }
    return result;
}

int ::readUleb128(){
    return Leb128->readUnsignedLeb128(this);
}

int ::readUleb128p1(){
    return Leb128->readUnsignedLeb128(this)-1;
}

int ::readSleb128(){
    return Leb128->readSignedLeb128(this);
}

void ::writeUleb128p1(int i){
    writeUleb128(i+1);
}

TypeList* ::readTypeList(){
    int size=readInt();
    short[] types=readShortArray(size);
    alignToFourBytes();
    return new TypeList(this,types);
}

String* ::readString(){
    int offset=readInt();
    int savedPosition=data->position();
    int savedLimit=data->limit();
    data->position(offset);
    data->limit(data->capacity());
    try{
        int expectedLength=readUleb128();
        String* result=Mutf8->decode(this,new char[expectedLength]);
        if(result->length()!=expectedLength){
            throw new DexException(new String("Declared length ")+expectedLength+new String(" doesn't match decoded length of ")+result->length())
        }
        return result;
    }catch(UTFDataFormatException e){
        throw new DexException(e)
    }{
        data->position(savedPosition);
        data->limit(savedLimit);
    }
}

FieldId* ::readFieldId(){
    int declaringClassIndex=readUnsignedShort();
    int typeIndex=readUnsignedShort();
    int nameIndex=readInt();
    return new FieldId(this,declaringClassIndex,typeIndex,nameIndex);
}

MethodId* ::readMethodId(){
    int declaringClassIndex=readUnsignedShort();
    int protoIndex=readUnsignedShort();
    int nameIndex=readInt();
    return new MethodId(this,declaringClassIndex,protoIndex,nameIndex);
}

ProtoId* ::readProtoId(){
    int shortyIndex=readInt();
    int returnTypeIndex=readInt();
    int parametersOffset=readInt();
    return new ProtoId(this,shortyIndex,returnTypeIndex,parametersOffset);
}

CallSiteId* ::readCallSiteId(){
    int offset=readInt();
    return new CallSiteId(this,offset);
}

MethodHandle* ::readMethodHandle(){
    MethodHandleType* methodHandleType=MethodHandleType->fromValue(readUnsignedShort());
    int unused1=readUnsignedShort();
    int fieldOrMethodId=readUnsignedShort();
    int unused2=readUnsignedShort();
    return new MethodHandle(this,methodHandleType,unused1,fieldOrMethodId,unused2);
}

ClassDef* ::readClassDef(){
    int offset=getPosition();
    int type=readInt();
    int accessFlags=readInt();
    int supertype=readInt();
    int interfacesOffset=readInt();
    int sourceFileIndex=readInt();
    int annotationsOffset=readInt();
    int classDataOffset=readInt();
    int staticValuesOffset=readInt();
    return new ClassDef(this,offset,type,accessFlags,supertype,interfacesOffset,sourceFileIndex,annotationsOffset,classDataOffset,staticValuesOffset);
}

Code* ::readCode(){
    int registersSize=readUnsignedShort();
    int insSize=readUnsignedShort();
    int outsSize=readUnsignedShort();
    int triesSize=readUnsignedShort();
    int debugInfoOffset=readInt();
    int instructionsSize=readInt();
    short[] instructions=readShortArray(instructionsSize);
    Try[] tries;
    CatchHandler[] catchHandlers;
    if(triesSize>0){
        if(instructions->length%2==1){
            readShort();
        }
        Section* triesSection=open(data->position());
        skip(triesSize*SizeOf->TRY_ITEM);
        catchHandlers=readCatchHandlers();
        tries=triesSection->readTries(triesSize,catchHandlers);
    }else{
        tries=new Try[0];
        catchHandlers=new CatchHandler[0];
    }
    return new Code(registersSize,insSize,outsSize,debugInfoOffset,instructions,tries,catchHandlers);
}

CatchHandler[] ::readCatchHandlers(){
    int baseOffset=data->position();
    int catchHandlersSize=readUleb128();
    CatchHandler[] result=new CatchHandler[catchHandlersSize];
    for(int i=0;i<catchHandlersSize;i){
        int offset=data->position()-baseOffset;
        iresult=readCatchHandler(offset);
    }
    return result;
}

Try[] ::readTries(int triesSize,CatchHandler[] catchHandlers){
    Try[] result=new Try[triesSize];
    for(int i=0;i<triesSize;i){
        int startAddress=readInt();
        int instructionCount=readUnsignedShort();
        int handlerOffset=readUnsignedShort();
        int catchHandlerIndex=findCatchHandlerIndex(catchHandlers,handlerOffset);
        iresult=new Try(startAddress,instructionCount,catchHandlerIndex);
    }
    return result;
}

int ::findCatchHandlerIndex(CatchHandler[] catchHandlers,int offset){
    for(int i=0;i<catchHandlers->length;i){
        CatchHandler* catchHandler=icatchHandlers;
        if(catchHandler->getOffset()==offset){
            return i;
        }
    }
    throw new IllegalArgumentException()
}

CatchHandler* ::readCatchHandler(int offset){
    int size=readSleb128();
    int handlersCount=Math->abs(size);
    int[] typeIndexes=new int[handlersCount];
    int[] addresses=new int[handlersCount];
    for(int i=0;i<handlersCount;i){
        itypeIndexes=readUleb128();
        iaddresses=readUleb128();
    }
    int catchAllAddress=size<=0?readUleb128():1;
    return new CatchHandler(typeIndexes,addresses,catchAllAddress,offset);
}

ClassData* ::readClassData(){
    int staticFieldsSize=readUleb128();
    int instanceFieldsSize=readUleb128();
    int directMethodsSize=readUleb128();
    int virtualMethodsSize=readUleb128();
    ClassData.Field[] staticFields=readFields(staticFieldsSize);
    ClassData.Field[] instanceFields=readFields(instanceFieldsSize);
    ClassData.Method[] directMethods=readMethods(directMethodsSize);
    ClassData.Method[] virtualMethods=readMethods(virtualMethodsSize);
    return new ClassData(staticFields,instanceFields,directMethods,virtualMethods);
}

ClassData.Field[] ::readFields(int count){
    ClassData.Field[] result=new ClassData.Field[count];
    int fieldIndex=0;
    for(int i=0;i<count;i){
        fieldIndex+=readUleb128();
        int accessFlags=readUleb128();
        iresult=new ClassData.Field(fieldIndex,accessFlags);
    }
    return result;
}

ClassData.Method[] ::readMethods(int count){
    ClassData.Method[] result=new ClassData.Method[count];
    int methodIndex=0;
    for(int i=0;i<count;i){
        methodIndex+=readUleb128();
        int accessFlags=readUleb128();
        int codeOff=readUleb128();
        iresult=new ClassData.Method(methodIndex,accessFlags,codeOff);
    }
    return result;
}

byte[] ::getBytesFrom(int start){
    int end=data->position();
    byte[] result=new byte[end-start];
    data->position(start);
    data->get(result);
    return result;
}

Annotation* ::readAnnotation(){
    byte visibility=readByte();
    int start=data->position();
    new EncodedValueReader(this,EncodedValueReader->ENCODED_ANNOTATION)->skipValue();
    return new Annotation(this,visibility,new EncodedValue(getBytesFrom(start)));
}

EncodedValue* ::readEncodedArray(){
    int start=data->position();
    new EncodedValueReader(this,EncodedValueReader->ENCODED_ARRAY)->skipValue();
    return new EncodedValue(getBytesFrom(start));
}

void ::skip(int count){
    if(count<0){
        throw new IllegalArgumentException()
    }
    data->position(data->position()+count);
}

void ::alignToFourBytes(){
    data->position(data->position()+3&3);
}

void ::alignToFourBytesWithZeroFill(){
    while(data->position()&3!=0){
        data->put(0);
    }
}

void ::assertFourByteAligned(){
    if(data->position()&3!=0){
        throw new IllegalStateException(new String("Not four byte aligned!"))
    }
}

void ::write(byte[] bytes){
    this->data->put(bytes);
}

void ::writeByte(int b){
    data->put(b);
}

void ::writeShort(short i){
    data->putShort(i);
}

void ::writeUnsignedShort(int i){
    short s=i;
    if(i!=s&0xffff){
        throw new IllegalArgumentException(new String("Expected an unsigned short: ")+i)
    }
    writeShort(s);
}

void ::write(short[] shorts){
    for(short s:shorts){
        writeShort(s);
    }
}

void ::writeInt(int i){
    data->putInt(i);
}

void ::writeUleb128(int i){
    try{
        Leb128->writeUnsignedLeb128(this,i);
    }catch(ArrayIndexOutOfBoundsException e){
        throw new DexException(new String("Section limit ")+data->limit()+new String(" exceeded by ")+name)
    }
}

void ::writeSleb128(int i){
    try{
        Leb128->writeSignedLeb128(this,i);
    }catch(ArrayIndexOutOfBoundsException e){
        throw new DexException(new String("Section limit ")+data->limit()+new String(" exceeded by ")+name)
    }
}

void ::writeStringData(String* value){
    try{
        int length=value->length();
        writeUleb128(length);
        write(Mutf8->encode(value));
        writeByte(0);
    }catch(UTFDataFormatException e){
        throw new AssertionError()
    }
}

void ::writeTypeList(TypeList* typeList){
    short[] types=typeList->getTypes();
    writeInt(types->length);
    for(short type:types){
        writeShort(type);
    }
    alignToFourBytesWithZeroFill();
}

int ::used(){
    return data->position()-initialPosition;
}

String* ::get(int index){
    checkBounds(index,tableOfContents->stringIds->size);
    return open(tableOfContents->stringIds->off+index*SizeOf->STRING_ID_ITEM)->readString();
}

int ::size(){
    return tableOfContents->stringIds->size;
}

Integer ::get(int index){
    return descriptorIndexFromTypeIndex(index);
}

int ::size(){
    return tableOfContents->typeIds->size;
}

String* ::get(int index){
    return strings->get(descriptorIndexFromTypeIndex(index));
}

int ::size(){
    return tableOfContents->typeIds->size;
}

ProtoId* ::get(int index){
    checkBounds(index,tableOfContents->protoIds->size);
    return open(tableOfContents->protoIds->off+SizeOf->PROTO_ID_ITEM*index)->readProtoId();
}

int ::size(){
    return tableOfContents->protoIds->size;
}

FieldId* ::get(int index){
    checkBounds(index,tableOfContents->fieldIds->size);
    return open(tableOfContents->fieldIds->off+SizeOf->MEMBER_ID_ITEM*index)->readFieldId();
}

int ::size(){
    return tableOfContents->fieldIds->size;
}

MethodId* ::get(int index){
    checkBounds(index,tableOfContents->methodIds->size);
    return open(tableOfContents->methodIds->off+SizeOf->MEMBER_ID_ITEM*index)->readMethodId();
}

int ::size(){
    return tableOfContents->methodIds->size;
}

boolean ::hasNext(){
    return count<tableOfContents->classDefs->size;
}

ClassDef* ::next(){
    if(hasNext()){
        throw new NoSuchElementException()
    }
    count;
    return in->readClassDef();
}

void ::remove(){
    throw new UnsupportedOperationException()
}

Iterator<ClassDef>* ::iterator(){
    return tableOfContents->classDefs->exists()?Collections->emptySet()->iterator():new ClassDefIterator();
}

